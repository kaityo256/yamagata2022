# モンテカルロ法(1)基礎的な話題

* 乱数とはなにか
* モンテカルロ法
* マルコフ連鎖モンテカルロ法とメトロポリス法
* エラーバーについて

## はじめに

モンテカルロ法とは、乱数を使って何かを評価する方法です。一般には単純なモンテカルロ法が使われることは稀で、ほとんどの場合「モンテカルロ法」と言うとマルコフ連鎖モンテカルロ法のことを指します。モンテカルロ法の原理は非常に単純であり、コードも比較的容易です。しかし、その本質の理解はかなり難しいものです。以下では、乱数の説明からはじめ、モンテカルロ法とはなにか、なぜ必要なのか、何が難しいのかをなるべく平易に説明しようと思います。

## 乱数とはなにか？

まずは乱数を定義しましょう。何か数列$r_i$があるとします。$r_0$から$r_i$まで既知である時、$r_{i+1}$を全く予想できない時、この数列を**乱数列(random sequence)**、乱数列のそれぞれの要素を**乱数(random number)**と呼びます。簡単な例はサイコロです。$i$回目に振った時のサイコロの目を$r_i$としましょう。この時、$r_i$は1から6までのどれかの値を取ります。さて、いま5回サイコロを振って、「1,5,3,2,2,2」という目が出たとしましょう。この時、7回目のサイコロの目$r_7$を予想できるでしょうか？イカサマの無いサイコロであれば、$r_7$が取る値は1から6まで等確率であり、これまでの履歴に依りません。このように、過去の履歴から次の値が全く予想できないので、「サイコロを振ってでてきた目の履歴」は乱数列とみなせます。

乱数はコンピュータでよく使われています。例えばゲームでは乱数は欠かせません。ソシャゲのガチャや、RPGの「会心の一撃」、ポケットモンスターの個体差などに乱数が使われています。コンピュータで使われる乱数は、これまでの履歴から次の数を作っているため、原理的には次の数が予想可能です。このような乱数を**疑似乱数(pseudo random number)**と呼びます。数値計算で使う乱数は疑似乱数なので、単に乱数と言うと疑似乱数のことを指します。

一方、真の意味で次の数が予想できない「本当の乱数」を「真乱数」と呼びます。新乱数は、熱雑音や、放射性物質の崩壊など、物理現象を利用して生成します。このような装置を物理乱数生成器と呼びます。サイコロも一種の物理乱数生成器と言えます。一部のCPUには、物理乱数生成器を搭載しているものもあります(例えばIntelのrdrandなど)。

疑似乱数は、一見すると乱数に見えますが、周期性があったり、十分に長い履歴を知ると次の値が予想できたりするため、たとえばセキュリティ目的などに使う場合は注意が必要です。しかし、数値計算で使う乱数は

* 十分に周期性が長い(相関がほとんど無い)
* 出現する数に偏りがない(一様性)

さえ満たされていれば、予測可能であっても問題ありません。逆に、同じ乱数の種からは同じ乱数列が生成されることを積極的に利用し、乱数を使ったコードのデバッグを行ったりします。疑似乱数を生成するアルゴリズムはいろいろありますが、現在広く使われているのはメルセンヌ・ツイスター法です。ほとんどのプログラミング言語において、乱数を生成する関数のデフォルトに選ばれています。一方、Xorshift法という、極めて高速に動作し、乱数の性質も(メルセンヌ・ツイスターには及ばないものの)非常に良い手法も提案されており、Google ChromeのJavaScriptの乱数生成関数`Math.random()`に採用されています。

疑似乱数生成アルゴリズムについては詳しくは触れませんが、その性質と使い方だけ簡単に見ておきましょう。Pythonで乱数を使うには`random`を`import`してから`random.random()`を呼び出します。これは、呼び出すたびに異なる0から1までの浮動小数点数を返す関数です。

```py
import random
for _ in range(5):
    print(random.random())
```

実行するたびに異なる値が表示されます。

```sh
$ python3 rand.py
0.7183142085184294
0.625356371754038
0.8206028825940407
0.5122008096362916
0.7253633754087734

$ python3 rand.py
0.3618195051209263
0.7496549080606681
0.3396919019733251
0.9722928645993307
0.3532634875426808
```

しかし、「乱数の種」を指定すると、何度実行しても同じ数列が表示されます。

```py
import random
random.seed(1)
for _ in range(5):
    print(random.random())
```

```sh
$ python3 rand.py
0.13436424411240122
0.8474337369372327
0.763774618976614
0.2550690257394217
0.49543508709194095

$ pyton3 rand.py
0.13436424411240122
0.8474337369372327
0.763774618976614
0.2550690257394217
0.49543508709194095
```

疑似乱数生成は、これまでの履歴をうまいこと使って次の数を作るアルゴリズムです。最初の「種」が同じならば、履歴が同じになり、必ず同じ数列が得られます。Pythonで種を指定しなかった場合に毎回異なる数列が得られたのは、種を指定しなかった場合にシステム時刻が指定されるからです。

一方、C++では、乱数の種を指定しなければ同じ種が使われるため、何度実行しても同じ結果になります。

```cpp
#include <iostream>
#include <random>

int main() {
  std::mt19937 mt;
  std::uniform_real_distribution<> ud(0.0, 1.0);
  for (int i = 0; i < 5; i++) {
    std::cout << ud(mt) << std::endl;
  }
}
```

```sh
$ g++ rand.cpp
$ ./a.out
0.135477
0.835009
0.968868
0.221034
0.308167

$ ./a.out
0.135477
0.835009
0.968868
0.221034
0.308167
```

このように、乱数生成にい同じアルゴリズムを使っていても、異なる言語では異なる仕様になっていたりするので注意が必要です。

## モンテカルロ法

モンテカルロ法とは、乱数を使ってなにかの期待値を計算する手法の総称です。

### 単純サンプリング

いま、普通のサイコロがあったとしましょう。1から6までの目が書いてあります。それぞれの目の出る確率が等しい時、サイコロの目の期待値はどれくらいでしょうか？答えはすぐに「3.5」だとわかりますが、後のためにもう少しきちんと議論しておきましょう。しばらく「当たり前」の議論が続きますが、我慢してついてきてください。

サイコロの目の期待値とは、サイコロをなんども振った時に出る目の合計を、振った回数でわったものです。サイコロを$N$回振ることにします。$i$回目に出た目を$\hat{X}_i$としましょう。サイコロを$N$回振った平均を$\bar{X}$とすると、

$$
\bar{X} = \frac{1}{N} \sum_i X_i
$$

となります。

サイコロの目として$k$が出る確率を$p_k$としましょう。今回は全ての目の出る確率が等しいので、$p_k$は$k$に寄らず$1/6$です。
