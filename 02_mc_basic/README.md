# モンテカルロ法(1)基礎的な話題

* 乱数とはなにか
* モンテカルロ法
* マルコフ連鎖モンテカルロ法とメトロポリス法
* エラーバーについて

## はじめに

モンテカルロ法とは、乱数を使って何かを評価する方法だ。一般には単純なモンテカルロ法が使われることは稀で、ほとんどの場合「モンテカルロ法」と言うとマルコフ連鎖モンテカルロ法のことを指す。モンテカルロ法の原理は非常に単純であり、コードも比較的容易だ。しかし、その本質の理解はかなり難しい。以下では、乱数の説明からはじめ、モンテカルロ法とはなにか、なぜ必要なのか、何が難しいのかをなるべく平易に説明する。

## 乱数とはなにか？

まずは乱数を定義しよう。何か数列$r_i$があるとする。$r_0$から$r_i$まで既知である時に$r_{i+1}$を全く予想できない時、この数列を**乱数列(random sequence)**、乱数列のそれぞれの要素を**乱数(random number)**と呼ぶ。簡単な例はサイコロだ。$i$回目に振った時のサイコロの目を$r_i$としよう。この時、$r_i$は1から6までのどれかの値を取る。さて、いま5回サイコロを振って、「1,5,3,2,2,2」という目が出たとする。この時、7回目のサイコロの目$r_7$を予想できるだろうか？イカサマの無いサイコロであれば、$r_7$が取る値は1から6まで等確率であるから、過去の履歴を知っているからといって、値を当てる確率は増えない。このように、過去の履歴から次の値が全く予想できないため、「サイコロを振ってでてきた目の履歴」は乱数列とみなすことができる。

乱数はコンピュータでよく使われている。例えばゲームでは乱数は欠かせない。ソシャゲのガチャや、RPGの「会心の一撃」、ポケットモンスターの個体差などに乱数が使われている。コンピュータで使われる乱数は、これまでの履歴から次の数を作っているため、原理的には次の数が予想可能だ。このような乱数を**疑似乱数(pseudo random number)**と呼ぶ。数値計算で使う乱数は疑似乱数であるため、単に乱数と言うと疑似乱数のことを指す。

一方、真の意味で次の数が予想できない「本当の乱数」を「真乱数」と呼び、疑似乱数と区別することがある。真乱数は、熱雑音や、放射性物質の崩壊など、物理現象を利用して生成する。このような装置を物理乱数生成器と呼ぶ。サイコロも一種の物理乱数生成器と言える。一部のCPUには、物理乱数生成器を搭載しているものもある(例えばIntelのrdrandなど)。

疑似乱数は、一見すると乱数に見えるが、周期性があったり、十分に長い履歴を知ると次の値が予想できたりするため、たとえばセキュリティ目的などに使う場合は注意が必要だ。しかし、数値計算で使う乱数は

* 十分に周期性が長い(相関がほとんど無い)
* 出現する数に偏りがない(一様性)

という条件さえ満たされていれば、予測可能であっても問題ないことが多い。逆に、同じ乱数の種からは同じ乱数列が生成されることを積極的に利用し、乱数を使ったコードのデバッグを行う。疑似乱数を生成するアルゴリズムはいろいろあるが、現在広く使われているのはメルセンヌ・ツイスター法で、ほとんどのプログラミング言語において、乱数を生成する関数のデフォルトに選ばれている。一方、Xorshift法という、極めて高速に動作し、乱数の性質も(メルセンヌ・ツイスターには及ばないものの)非常に良い手法も提案されており、Google ChromeのJavaScriptの乱数生成関数`Math.random()`に採用されている。

疑似乱数生成アルゴリズムについては詳しくは触れないが、その性質と使い方だけ簡単に見ておこう。例えばPythonで乱数を使うには`random`を`import`してから`random.random()`を呼び出す。これは、呼び出すたびに異なる0から1までの浮動小数点数を返す関数だ。

```py
import random
for _ in range(5):
    print(random.random())
```

実行するたびに異なる値が表示される。

```sh
$ python3 rand.py
0.7183142085184294
0.625356371754038
0.8206028825940407
0.5122008096362916
0.7253633754087734

$ python3 rand.py
0.3618195051209263
0.7496549080606681
0.3396919019733251
0.9722928645993307
0.3532634875426808
```

しかし、「乱数の種」を指定すると、何度実行しても同じ数列が表示される。

```py
import random
random.seed(1)
for _ in range(5):
    print(random.random())
```

```sh
$ python3 rand.py
0.13436424411240122
0.8474337369372327
0.763774618976614
0.2550690257394217
0.49543508709194095

$ pyton3 rand.py
0.13436424411240122
0.8474337369372327
0.763774618976614
0.2550690257394217
0.49543508709194095
```

疑似乱数生成は、これまでの履歴をうまいこと使って次の数を作るアルゴリズムであるから、乱数の「種」が同じならば、履歴が同じになり、必ず同じ数列が得られる。Pythonで種を指定しなかった場合に毎回異なる数列が得られたのは、種を指定しなかった場合にシステム時刻が指定されるからだ。

一方、C++では、乱数の種を指定しなければ同じ種が使われるため、何度実行しても同じ結果になる。

```cpp
#include <iostream>
#include <random>

int main() {
  std::mt19937 mt;
  std::uniform_real_distribution<> ud(0.0, 1.0);
  for (int i = 0; i < 5; i++) {
    std::cout << ud(mt) << std::endl;
  }
}
```

```sh
$ g++ rand.cpp
$ ./a.out
0.135477
0.835009
0.968868
0.221034
0.308167

$ ./a.out
0.135477
0.835009
0.968868
0.221034
0.308167
```

このように、乱数生成にい同じアルゴリズムを使っていても、異なる言語では異なる仕様になっていたりするので注意が必要だ。

## モンテカルロ法

モンテカルロ法とは、乱数を使ってなにかの期待値を計算する手法の総称だ。数値計算において、なにかの期待値を計算したいことがよくある。しかし、興味ある系において期待値が厳密に計算できることはほとんどないため、乱数を使ったサンプリングにより期待値を求めることになる。

モンテカルロ法の例として「円周率の計算」がよく出てくる。0から1の間の一様乱数を$x$、$y$と二つ作り、その二乗和$x^2+y^2$が1より小さい確率を求めることで、それが$\pi/4$となることから円周率が求まる。

たとえばコードはこんな感じになるだろう。

```py
import random

random.seed(1)
pi = 0.0
N = 1000000
for _ in range(N):
    x = random.random()
    y = random.random()
    if x**2 + y**2 < 1.0:
        pi = pi + 1.0
pi = pi/N*4
print(pi)
```

実行結果はこうなる。

```sh
$ python3 pi.py
3.14138
```

この計算は、数式で表すなら以下の積分を実行していることに対応する。

$$
\frac{\pi}{4} = \int_0^1 \int_0^1 \Theta (1- x^2 + y^2) dx dy
$$

ここで$\Theta(x)$は、$x>0$なら$1$、$x<0$なら$0$となる関数(ヘヴィサイドの階段関数)だ。先程のコードは、サンプリングによりこの積分値を評価していることに対応する。このように、モンテカルロ法は「式は書けるけれど、厳密に評価することが難しい和や積分」の評価に使われる。

さて、ここで使われた手法は単純サンプリングと呼ばれ、効率がよくない。数値計算で使われるモンテカルロ法は、ほぼ「マルコフ連鎖モンテカルロ法」のことを指す。以下では、まず単純サンプリングで用語の説明をした後、マルコフ連鎖モンテカルロ法について説明する。

### 単純サンプリング

いま、公平なサイコロがあったとしよう。1から6までの目が書いてある。それぞれの目の出る確率が等しい時、サイコロの目の期待値はどれくらいだろうか？答えはすぐに「3.5」だとわかるが、後のために用語を定義しながらきちんと議論しておく。しばらく「当たり前」の議論が続くが、我慢してついてきて欲しい。

サイコロの目の状態に通し番号をつけ、$k$番目の状態の目の値を$Y_k$で表現する。$k$は1から6までで、$Y_k = k$だ。状態$k$が出る確率を$p_k$としよう。この時、サイコロの目の期待値$\bar{X}$は、以下のように表現できる。

$$
\bar{X} = \sum_{k=1}^6 Y_k p_k = \sum_{k=1}^6 k p_k
$$

公平なサイコロであれば、全ての目の出る確率が等しいため、$p_k$は$k$に寄らず$1/6$だ。したがって、

$$
\bar{X} = \sum_{k=1}^6 \frac{k}{6} = 3.5
$$

と期待値が厳密に計算できる。さて、サイコロが公平であることを事前に知らない、もしくは確信が持てないとしよう。すると、どの目がどれくらい出るかわからない。したがって、目として$k$が出る確率$p_k$を推定してやる必要がある。

まずは何度もサイコロを振って、$k$が出た回数を数えよう。これを$w_k$とする。サイコロを振った回数の総数$N$は、$w_k$の和で表せる。

$$
N = \sum_k w_k
$$

そして、$k$が出る確率$p_k$は、$N$と$w_k$の比として推定できる。

$$
p_i \sim \frac{w_k}{N}
$$

以上から、サイコロの目の期待値は

$$
\bar{X} = \sum_k k p_k \sim \sum_k k \frac{w_k}{N}
$$

さて、サイコロを何度も振り、$i$回目に出た目が$\hat{X}_i$だったとしよう。サイコロを$N$回振って、出た目が$k$であった回数は以下のように書ける。

$$
w_k = \sum_{i=1}^N \delta_{\hat{X}_i, k}
$$

$\delta_{\mu,\nu}$はクロネッカーのデルタで、$\mu=\nu$の時に1、そうでなければ0となるものだ。わざわざ式で書いているが、サイコロの目が出た回数を数えているだけだ。確率の問題では、このように「当たり前」のことを式で表現すると面倒な形になることが多い。

さて、$w_k$を先の式に代入しよう。

$$
\bar{X} \sim \sum_k k \frac{w_k}{N} =
\frac{1}{N} \sum_k k \sum_{i=1}^N \delta_{\hat{X}_i, k}
$$

和を入れ替える。

$$
\sum_k k \sum_{i=1}^N \delta_{\hat{X}_i, k}
= \sum_{i=1}^N \sum_k k \delta_{\hat{X}_i, k}
$$

$k\delta_{\hat{X}_i, k}$は、$\hat{X}_i = k$の時にkに、それ以外は$0$となるから、$k$に関して和を取ると、単純に$\hat{X}_i$になる。

以上から、

$$
\hat{X} \sim \frac{1}{N} \sum_{i=1}^N \hat{X}_i
$$

を得た。要するに何度もサイコロを振って、その平均を取りなさい、と言ってるだけだ。

さて、上記の議論では、サイコロの目$k$が出る時の重み$w_k$が未知だが、実際にサイコロを振ることで、サイコロの目$k$が$p_k$に従って出現することを利用していた。しかし、数値計算では、$w_k$も$p_k$も未知だが、$p_k$に従って状態$k$が出現してくれるようなシチュエーションは存在せず、状態$k$の重み$w_k$が既知だが、その総和$Z$を求めることができず、結果として$p_k$が未知である状態であることがほとんどだ。その場合にどのように期待値を推定するか見てみよう。

我々は状態$k$の重み$w_k$が既知であるが、その総和$Z$が未知であるとする。その状態で、

$$
\bar{X} = \sum_k k p_k
$$

を推定したい。

$$
p_k = \frac{w_k}{\sum_k w_k}
$$

であるから、

$$
\bar{X} = \frac{\sum_k k w_k}{\sum_k w_k}
$$

となる。まずは分母を評価することを考えよう。

$$
Z = \sum_k w_k
$$

和のままでも議論できるが、積分の方がわかりやすいので、$k$が十分に大きいとして積分だと思うことにしよう(もとがサイコロなので$k$は大きくないが、ここでは見逃してもらうことにする)。$k$の最小値、最大値をそれぞれ$k_\mathrm{min},k_\mathrm{max}$とすると、

$$
Z = \int_{k_\mathrm{min}}^{k_\mathrm{max}} w(k) dk
$$

となる。この積分を、乱数を使って評価しよう。$k_\mathrm{min} < \hat{X} < k_\mathrm{max}$であるような一様乱数を考える。この乱数を$N$回生成させ、その$i$番目の値を$\hat{X}_i$とする。一度出現させた乱数$\hat{X}_i$に、領域を$N$等分した範囲

$$
\Delta k \equiv \frac{k_\mathrm{max}- k_\mathrm{min}}{N}
$$

をかけて、小さい短冊の和として積分を評価してやる。すると、

$$
Z = \sum_k w_k \sim \sum_i w_{\hat{X}_i} \Delta k
$$

となる。同様に分子も、

$$
\sum_k k w_k \sim \sum_i \hat{X}_i w_{\hat{X}_i} \Delta k
$$

となる。以上から、平均値の推定値は

$$
\bar{X} = \frac{\sum_k k w_k}{\sum_k w_k}
\sim \frac{\sum_i \hat{X}_i w_{\hat{X}_i}}{\sum_i w_{\hat{X}_i}}
$$

と推定される。このように、なにかの期待値をランダムな標本を使って推定する手法を**サンプリング**と呼ぶ。特に、まずは重みに関係なく状態を一様に生成し、その後で重みをかけて平均をとる手法を **単純サンプリング**と呼ぶ。

サイコロのように、もし$w_k$が全て等しいのなら、$w_k = 1$とおいて良いから、

$$
\bar{X} = \frac{1}{N} \sum_i \hat{X}_i
$$

と、先程の式と一致する。また、前述の円周率の推定では、重みは四分円の中なら1、外なら0とした単純サンプリングになっている。

単純サンプリングについてまとめて置こう。

* 一般には、ある状態の重みは既知だが、重みの総和が求まらないために、状態の出現確率が未知であることが多い
* なにかを調べたい時に、全てを調べるのではなく、一部の標本を抜き出して調べることをサンプリングと呼ぶ
* なにかの期待値を乱数を使って評価する手法をモンテカルロ法と呼ぶ。
* 出現可能な状態を一様に選び、重みをかけて期待値を推定する手法を単純サンプリングと呼び、モンテカルロ法の最も簡単な例

### 状態数

公平なサイコロの要件は、全ての目の出現重みが等しいことだ。$w_k$はお互いの比だけが問題となるので、$w_k = 1$としよう。すると、$Z=6$、$p_k = 1/6$となる。我々が「公平なサイコロを振ったら、各目が出る確率が1/6だ」という時には、

* 各サイコロの目がでる重みは等しい $w_k = 1$
* サイコロには目の種類が6個あるので、重みの和は$Z = \sum_k w_k = 6$となる
* したがって、各目の出現確率は$p_k = w_k/Z = 1/6$となる

という論理を無意識に使っている。

さて、普通のサイコロでは、全ての目が異なっていたため、$k$番目の状態の目の値$Y_k$は$k$に等しく、単に$k$で置き換えればよかった。後の布石のために、目に重複のあるサイコロを考えてみよう。

6面に「1,2,2,3,3,3」と描かれたサイコロがあるとしよう。この6つの状態の出現頻度は等しいとする。$k$番目の状態の目の値を$Y_k$とする。つまり、
$$
Y_1 = 1, Y_2 = 2, Y_3 = 2, Y_4 = 3,Y_5 = 3,Y_6 = 3
$$
だ。もともとが公平なサイコロなので、6つの状態が等しい重み$w_i=1$を持っているとしよう。すると、このサイコロの目の期待値は

$$
\bar{X} = Z^{-1} \sum_{k=1}^6 Y_k w_k
$$

と書ける。ただし$Z = \sum_k w_k$だ。ここで、状態は6種類あるが、値は1,2,3の3種類しかないことに注目し、値について和をまとめてしまおう。いま、値$j$を取る状態の数を$g_j$とする。今回のケースでは$g_1 = 1, g_2 = 2, g_3 = 3$だ。

すると、和を値で取りなおすことができる。

$$
\bar{X} = Z^{-1} \sum_{j=1}^3 j g_j w_j
$$

となる。

ここまでの用語の整理をすると、

* 値$j$を持つ状態の重みが$w_j$
* 値$j$を持つ状態の状態数が$g_j$個である時、
* 重みの総和を$Z=\sum_j g_j w_j$として、
* 値の期待値は$Z^{-1} \sum j g_j p_j$で書ける

という、至極当たり前のことを言っているだけだ。

「値が重複するサイコロ」をもう少し深堀りしよう。今は6つの状態全ての重みが等しかったが、状態に重複があったため、「値」で和を取ると状態数がかかった。そこで$w_j g_j$を、改めて値$j$を取る状態の重み$w'_j$だと考えよう。

とり得る状態は3つ、値は$1,2,3$、重みは$w'_1 = 1, w'_2 = 2, w'_3 =3$となる。すると、期待値は

$$
\bar{X} = \frac{\sum_j k w'_k}{\sum_j w'_k}
$$

と表現できる。先程と同様に、全ての状態$j$の重み$w'_j$は既知だが、その総和が未知である時、この和を単純サンプリングで評価することを考えよう。1,2,3のいずれかの値を当確率で取る乱数を$N$個作成し、その$i$番目の値を
$\hat{X}_i$をとすると、期待値は以下のように推定できる。

$$
\bar{X} \sim \frac{\sum_i^N \hat{X}_i w'_{\hat{X}_i}}{\sum_i^N w'_{\hat{X}_i}}
$$

手続きを言葉で書くと以下の通り。

1. 1,2,3のいずれかの値を取る乱数をを作る
2. 出現した値に対応する重みに値をかけて和をとる(分母の推定)
3. 出現した値に対応する重みの和をとる(分子の推定)
4. 十分な和が取れたら、それらの比を取る

こちらのケースでは、重みが一様ではないので、分子と分母がキャンセルせず、簡単な形にならないことに注意。

## マルコフ連鎖モンテカルロ法

### 格子ガス模型

なにかランダムな値の期待値を計算したい時、その値を取る状態の出現頻度(重み)と、その値を取る状態の数(状態数)を知る必要があった。たとえば公平なサイコロの例では、重みも状態数も1であり、重複のあるサイコロでは、「重みが一様で状態数が異なる」もしくは「状態数が一様で、重みが異なる」であった。一般には、状態数も重みも一様ではなく、かつ重みの総和も状態数も厳密に求めることは難しい。以下では、サイコロより非自明で、かつ物理的にも興味深い例として気液相転移を考えよう。相転移とは、温度等を変化させた時に、ミクロな性質は変わらないにも関わらず、マクロな性質が大きく変化することだ。例えば、大気圧下において水は100度で沸騰して水蒸気になるが、ミクロにみれば水分子の性質は全く変わっていない。水分子同士の相互作用は温度に依存しないと思われるのに、温度により固体、液体、気体と、全く振る舞いが異なる状態になる。このうち、気体と液体の相転移を考えてみよう。原子が近距離で斥力、中間距離で引力、遠距離で相互作用しないという条件を満たすと気体と液体の相転移がおきる。これを非常に単純化し、格子上に原子を置く格子ガス模型を考えてみる。

$V = L x L$の正方格子を考える。この格子の上に$N$個の原子を置こう。「近距離で斥力」を表現するため、原子は一つのサイトに一つしか置けないことにする。また、「中間距離で引力」を表現するため、原子が上下左右に隣り合う場合は、$\epsilon$だけエネルギーが下がることにする。原子が上下左右に隣り合っていない時には、なんら相互作用をしないことで、遠距離で相互作用しないことを表現しよう。後の簡単のため、周期境界条件を採用する。

系は離散的であり、状態の数え上げが可能なので、全ての状態に通し番号$k$をつけよう。状態$k$のエネルギーを$E_k$とする。この状態の出現確率は、ボルツマン重み
$$
w_k = \exp(-\beta E_k)
$$
に比例するのであった。ここで、$\beta$は$k_B$はボルツマン定数、$T$は絶対温度として$\beta = 1/k_B T$で表される逆温度だ。これは、エネルギーが低い状態ほど出現しやすいことを表現している。

状態$k$の出現確率$p_k$は、重み$w_k$の総和
$$
Z = \sum_k w_k
$$
を使って
$$
p_k = \frac{w_k}{Z}
$$
と書ける。すると、ある温度におけるエネルギーの期待値は
$$
U(T) = \sum_k E_k p_k = Z^{-1} \sum_k E_k w_k
$$

と表すことができる。この$U(T)$を様々な温度$T$で計算するのが目的だ。なんとなく、温度が低い時には偏った状態(液相)となってエネルギーが下がり、温度が高いと原子がバラバラな状態(気相)になってエネルギーが上がりそうな気がする。それを確認しよう。

簡単のため、二原子系($N=2$)を考える。原子が二つなので、それが隣り合っていればエネルギーは$-\epsilon$、そうでなければ$0$と、エネルギーのとり得る値は二種類だ。それを$E_0 = -\epsilon$、$E_1 = 0$と名前をつけて、先程の「値が重複しているサイコロ」の例にならって、同じエネルギーを持つ状態で和をまとめよう。エネルギー$E_j$をとる状態の重みを$w_j$、状態数を$g_j$とすると、重みの和$Z$は

$$
\begin{aligned}
Z &= \sum_k w_k \\
&= \sum_j g_j w_j \\
&= g_0 w_0 + g_1 w_1 \\
&= g_0 \mathrm{e}^{\beta \epsilon} + g_1 \\
&= g_0 \mathrm{e}^K + g_1 \\
\end{aligned}
$$

と書ける。ただし$K=\beta \epsilon$とした。

すると、エネルギーの期待値は

$$
\begin{aligned}
U(T) &= Z^{-1} \sum_j E_j g_j w_j\\
&= \frac{E_0 g_0 w_0 +E_1 g_1 w_1}{Z} \\
&= \frac{-\epsilon g_0 \mathrm{e}^K}{g_0 \mathrm{e}^K + g_1}
\end{aligned}
$$

と書けた。以上から、エネルギーの期待値の温度依存性は、あるエネルギーを取る状態数$g_0$、$g_1$を求めることに帰着された。

いま、格子の数は$V$個なので、そこに二つ原子を置く方法は全部で$V(V-1)/2$通りだ。したがって、

$$
g_0 + g_1 = \frac{V(V-1)}{2}
$$

となる。次に$g_0$は、二つの原子が隣り合っている状態の数だ。二原子分子の位置が$V$通り、分子の方向が$2$通りなので、合わせて$2V$通りとなる。以上から、

$$
\begin{aligned}
g_0 &= 2V \\
g_1 &= \frac{V(V-5)}{2}
\end{aligned}
$$

となり、これで内部エネルギーの厳密解がわかった。$V = 10^2$、$\epsilon = 1$として、内部エネルギーを$K$の関数としてプロットすると以下のようになる。

![n2.png](lattice_gas/n2.png)

$K=\beta \epsilon = \epsilon/k_B T$なので、$K$が小さいところが高温、大きいところが低温になる。高温(左側)でエネルギーが0となり、低温(右側)でエネルギーが$-1$に漸近しており、相転移っぽいものが見えていることがわかる。

さて、相転移は多数の自由度が集まることで起きる現象であるから、$N$を増やしたい。とりあえず次は三原子系としよう。すると、エネルギーとしてとり得る値は
$$
E_0=-2\epsilon, E_1 = -\epsilon, E_2 = 0
$$
の三種類だ。エネルギーの温度依存性を調べるためには、あるエネルギー$E_j$を取る状態の状態数$g_j$を求めなければならない。

エネルギーが$E_0$となる状態は、原子が３つつながった三原子分子となっている状態だ。３つが横並びになっているか、曲がった状態でつながっているかで場合分けすれば状態数$g_1$を求めることができる。

エネルギーが$E_1$となる状態は、三つの原子のうち、二つが二原子分子を構成し、残りがどこかにいる、という状態だ。これも頑張れば状態数$g_2$を計算できる。

$g_1$と$g_2$がわかれば、状態の総数はわかっているので$g_3$も計算できる。

では$N=4$の時は？$N=5$は？少し考えれば、$N$が増えるにつれて指数関数的に考えるべき条件が増え、一般の状態数を求めることができないことがわかるであろう。状態数$g_j$がわからないため、重みの総和$Z$も求めることができない。したがって、あるエネルギーを持つ一つの状態の出現確率も求めることができない。したがって、エネルギーの期待値を厳密に求めることができないので、モンテカルロ法によるサンプリングで求めることになる。

まずは単純サンプリングで求めることを考えよう。単純サンプリングは以下の手続きで実行できる。

1. 可能な状態の中から一つランダムな状態$i$を選ぶ
2. その状態のエネルギー$E_i$を計算する
3. エネルギーから重み$w_i$を計算する
4. これを繰り返し、$\sum E_i w_i$と$\sum w_i$の比を計算する
